<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Project â€” ëª¨ë°”ì¼</title>
  <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@700&family=Pretendard:wght@400;600;700;900&display=swap" rel="stylesheet">
  <link rel="preload" as="image" href="../../1.Picture/1. 27th Graduation/BLOOM_LOGO/1.png" />
  <style>
    :root{
      --line: rgba(255,255,255,.12);
      --content-max: 1000px; /* clamp width for big tablets like iPad Pro */
      --side-pad: 16px;      /* safe side padding on all widths */
      --nav-h: 64px; /* canonical TUVD mobile header height */
      --font-title: 'Playfair Display', serif;                     /* ì œëª© ì „ìš© */
     }
    
    /* Prevent any content from exceeding the viewport */
    main, .stage, .search-bar, .filter-scroll, .toolbar-count, .grid {
      width: min(100vw, 100%);
      max-width: 100vw;
    }

    /* Force text wrapping to avoid layout overflow (scoped to content area) */
    #fit-root *, #fit-root *::before, #fit-root *::after {
      word-break: break-word;
      overflow-wrap: anywhere;
    }

    html,body{
      margin:0;
      padding:0;
      background:#000;
      color:#fff;
      width:100%;
      max-width:100%;
      overflow-x:hidden; /* ğŸš« prevent horizontal scroll on iPad Pro */
      -webkit-text-size-adjust:100%;
      min-height:100%;
      font-family: var(--font-body); /* ...ê¸°ì¡´ ì†ì„± ìœ ì§€ */
    }
        
    body{ display:flex; flex-direction:column; min-height:100vh; }
    #fit-root, #fit-root *{ box-sizing: border-box; }

    /* ===== í˜ì´ì§€ íƒ€ì´í‹€/íˆ´ë°” ===== */
    /* ===== í˜ì´ì§€ íƒ€ì´í‹€/íˆ´ë°” ===== */
    .stage{ padding:18px 14px 72px; }
    h1.page-title{
      font:900 34px/1.15 'Playfair Display', serif;
      text-align:center;
      margin:18px 0 18px;
      letter-spacing:.2px;
      font-family: 'Playfair Display', serif;
    }

    .toolbar{ display:flex; align-items:center; justify-content:center; gap:10px; padding:8px 2px 10px; border-bottom:none; position:static; top:auto; background:transparent; }

    /* â–¶ ê°€ë¡œ ìŠ¤í¬ë¡¤ í•„í„° ë„¤ë¹„ê²Œì´ì…˜ */
    .filter-scroll{ 
      display:block; overflow-x:auto; overflow-y:hidden; white-space:nowrap; 
      -webkit-overflow-scrolling:touch; scrollbar-width:none; 
      padding:8px 12px;
      margin:0 auto;
      position:relative;
      max-width:100vw;
      overscroll-behavior-x: contain;
    }
    /* iOS/Chrome ì–‡ì€ ìŠ¤í¬ë¡¤ë°” ìˆ¨ê¹€ */
    .filter-scroll::-webkit-scrollbar{ height:0; }
    .filter-track{ display:inline-flex; align-items:center; gap:12px; padding:4px 0; }
    /* ë²„íŠ¼ì„ í…ìŠ¤íŠ¸ì²˜ëŸ¼ ë³´ì´ê²Œ, ì‚¬ì´ì— | êµ¬ë¶„ì ìë™ ìƒì„± */
    .pill{
      appearance:none; background:transparent; border:none; outline:none;
      color:#aaa; font-weight:700; font-size:15px; letter-spacing:.25px;
      padding:8px 16px; border-radius:20px; cursor:pointer; flex:0 0 auto;
      transition:color .2s ease, background .25s ease;
      font-family: 'Pretendard', 'Playfair Display', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
    }
    .pill:hover{ background:rgba(255,255,255,.08); color:#ff4d4d; }
    .pill.is-active{ background:rgba(255,77,77,.18); color:#ff4d4d; }

    .search-bar{ position:sticky; top:var(--nav-h); z-index:950; background:rgba(0,0,0,.72); backdrop-filter:blur(6px); -webkit-backdrop-filter:blur(6px); border-bottom:1px solid rgba(255,255,255,.12); padding:10px 12px; }
    .search-bar .search-wrap{ position:relative; display:block; }
    .search-bar .search-input{ width:100%; max-width:none; height:42px; padding:0 14px; border-radius:12px; border:1px solid rgba(255,255,255,.14); background:#151515; color:#eee; font-size:15px; }
    .toolbar-count{ display:flex; justify-content:flex-end; font-size:12px; color:#bbb; padding:4px 2px 0; }

    /* ===== ëª¨ë°”ì¼ ê·¸ë¦¬ë“œ ===== */
    .grid{
      display:grid;
      grid-template-columns: repeat(2, minmax(0,1fr));
      gap:12px;
      margin-top:14px;
      max-width:100vw;     /* keep inside viewport on iPad Pro */
      overflow-x:hidden;   /* extra safety */
    }
    @media (max-width:360px){ .grid{ grid-template-columns: 1fr; } }

    .card{ background:#0b0b0b; border:1px solid rgba(255,255,255,.06); border-radius:12px; overflow:hidden; }
    .card .card-link{ display:block; color:inherit; text-decoration:none; }
    .card img{ display:block; width:100%; height:auto; aspect-ratio: 1/1; object-fit:contain; background:#000;
max-width:100vw;
min-width:0;
contain:content;
}
    .cap{ padding:10px 10px 12px; }
    .cap .t{ font-weight:800; font-size:14px; line-height:1.25; color:#fff; font-family: 'Pretendard', 'Playfair Display', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; }
    .cap .m{ margin-top:6px; font-size:12px; color:#d0d0d0; font-family: 'Pretendard', 'Playfair Display', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; }

    footer{
      position:static;             /* ì½˜í…ì¸  ë’¤ë®ì§€ ì•ŠìŒ */
      margin-top:auto;             /* ë‚´ìš©ì´ ì§§ì•„ë„ í•˜ë‹¨ ì •ë ¬ */
      width:100%;
      background:#000;
      color:#f3f3f3;
      border-top:1px solid var(--line);
      height:36px;                 /* ğŸ”’ ê³ ì • ë†’ì´ (33 â†’ 36) */
      min-height:36px;             /* ì•ˆì „ì¥ì¹˜ */
      padding:0 12px;              /* ìˆ˜ì§ 0 â†’ ë†’ì´ ê³ ì • ìœ ì§€ */
      box-sizing:border-box;
      display:flex;                /* ìˆ˜ì§ ê°€ìš´ë° ì •ë ¬ */
      align-items:center;
      justify-content:center;
      font-size:12px;
      line-height:1;               /* ë¸Œë¼ìš°ì € ê¸°ë³¸ line-height ì°¨ì´ ì œê±° */
      text-align:center;
      font-family: 'Pretendard', system-ui, -apple-system, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
    }

    /* Final safety net: prevent any element from exceeding viewport width */
    @supports (width: min(100%, 100vw)){
      :where(body) > :not(#m-header-placeholder){ width:min(100%, 100vw); }
    }

    /* === View-fit scaler (iPad Pro: shrink content to fit without horizontal scroll) === */
    #fit-root{
      transform-origin: top center;
      will-change: transform;
      /* keep the scaled block centered */
      margin-left:auto;
      margin-right:auto;
      /* prevent scaled children from creating overflow */
      overflow-x: hidden;
      flex: 1 0 auto;
    }
    /* make sure scalable area never exceeds the viewport width before scaling */
    @supports (width: min(100%, 100vw)){
      #fit-root{ width: min(100%, 100vw); }
    }

  </style>
</head>
<body>
  <div id="m-header-placeholder"></div>
  <script>
    (function(){
      const mount = document.getElementById("m-header-placeholder");
      fetch("../../2.PageElement/Mobile-header/mobile-header.html")
        .then(res => res.text())
        .then(html => {
          mount.innerHTML = html;
          // === í—¤ë” ë‚´ë¶€ ë§í¬ë¥¼ í˜„ì¬ ë””ë ‰í„°ë¦¬ ê¸°ì¤€ìœ¼ë¡œ ì •ê·œí™” ===
          (function fixLinks(){
            const baseDir = location.pathname.replace(/[^/]*$/, '');
            const scope = mount; // í—¤ë”ê°€ ì£¼ì…ëœ ì˜ì—­
            // ë¡œê³  ë° ë©”ë‰´ ë‚´ ëª¨ë“  ì•µì»¤
            const anchors = scope.querySelectorAll('a');
            anchors.forEach(a => {
              const raw = a.getAttribute('href');
              if (!raw || raw.startsWith('#') || raw.startsWith('mailto:') || raw.startsWith('tel:')) return;
              try{
                // ì›ë˜ hrefë¥¼ ì ˆëŒ€ê²½ë¡œë¡œ í•´ì„
                const abs = new URL(raw, location.href);
                // íŒŒì¼ëª…(ë§ˆì§€ë§‰ ì„¸ê·¸ë¨¼íŠ¸)ë§Œ ì¶”ì¶œ
                const file = abs.pathname.split('/').pop();
                if (!file) return;
                // í˜„ì¬ ë””ë ‰í„°ë¦¬ ê¸°ì¤€ìœ¼ë¡œ ë§í¬ ì¬ì„¤ì •
                a.setAttribute('href', baseDir + file);
              }catch(e){ /* no-op */ }
            });
          })();
          // === í–„ë²„ê±° í† ê¸€ ë°”ì¸ë”© (includeëœ ìŠ¤í¬ë¦½íŠ¸ê°€ ì‹¤í–‰ë˜ì§€ ì•Šìœ¼ë¯€ë¡œ ì—¬ê¸°ì„œ ì—°ê²°) ===
          const btn = document.getElementById('menuBtn');
          const menu = document.getElementById('mMenu');
          const overlay = document.getElementById('menuOverlay');
          if (!btn || !menu) return;
          function setState(open){
            document.body.classList.toggle('nav-open', open);
            btn.setAttribute('aria-expanded', open ? 'true' : 'false');
            btn.setAttribute('aria-label', open ? 'ë©”ë‰´ ë‹«ê¸°' : 'ë©”ë‰´ ì—´ê¸°');
          }
          function toggle(){ setState(!document.body.classList.contains('nav-open')); }
          btn.addEventListener('click', toggle);
          if (overlay) overlay.addEventListener('click', () => setState(false));
          // ë©”ë‰´ ë§í¬ í´ë¦­ ì‹œ ìë™ ë‹«í˜
          menu.addEventListener('click', (e)=>{ if(e.target.closest('a')) setState(false); });
          // ESCë¡œ ë‹«ê¸° (ì„ íƒ)
          window.addEventListener('keydown', (e)=>{ if(e.key === 'Escape') setState(false); });
        })
        .catch(err => console.error("ëª¨ë°”ì¼ í—¤ë” ë¡œë“œ ì˜¤ë¥˜:", err));
    })();
  </script>

  <!-- ë³¸ë¬¸ (ìŠ¤ì¼€ì¼ ì»¨í…Œì´ë„ˆ) -->
  <div id="fit-root">
    <main class="stage">
    <h1 class="page-title">PROJECT</h1>
    <div class="search-bar">
      <div class="search-wrap">
        <input id="q" type="search" class="search-input" placeholder="í”„ë¡œì íŠ¸Â·ì´ë¦„Â·ì´ˆì„±â€¦" aria-label="ê²€ìƒ‰" />
      </div>
    </div>
    <div class="toolbar">
      <nav class="filter-scroll" aria-label="ì¹´í…Œê³ ë¦¬ í•„í„°">
        <div class="filter-track">
          <button class="pill is-active" data-filter="all">All</button>
          <button class="pill" data-filter="character">Character</button>
          <button class="pill" data-filter="ci-bi-package">BI/CI &amp; Package</button>
          <button class="pill" data-filter="uxui&editorial">UX/UI &amp; Editorial</button>
        </div>
      </nav>
    </div>
    <div class="toolbar-count" aria-live="polite">
      <span id="cnt">0 Project</span>
    </div>
    <section id="list" class="grid" aria-live="polite"></section>
  </main>
  </div>
  <footer>Â© TUVD 27th Graduate Exhibition â€¢ BLOOM</footer>

  <script>
    // === Auto-fit scaler (keeps all content inside viewport width on big tablets) ===
    (function fitToViewportWidth(){
      const root = document.getElementById('fit-root');
      if (!root) return;
      let raf = null;

      function measureAndScale(){
        // Temporarily reset transform to measure natural width
        root.style.transform = 'none';

        // The inner content width we want to fit (use scrollWidth to include grids)
        const naturalWidth = root.scrollWidth || root.getBoundingClientRect().width;
        const vw = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);

        // Padding safety (match side safe pad from :root if present)
        const sidePad = 0; // we already clamp with CSS; keep 0 here
        const available = vw - sidePad * 2;

        // Scale down only if content is wider than viewport
        const scale = naturalWidth > 0 ? Math.min(1, available / naturalWidth) : 1;

        // Apply scale
        root.style.transform = (scale < 1) ? `scale(${scale})` : 'none';

        // Prevent any phantom horizontal scroll from transforms
        document.documentElement.style.overflowX = 'hidden';
        document.body.style.overflowX = 'hidden';
      }

      function schedule(){
        if (raf) return;
        raf = requestAnimationFrame(()=>{ raf = null; measureAndScale(); });
      }

      // Initial and reactive
      window.addEventListener('DOMContentLoaded', schedule, { passive: true });
      window.addEventListener('load', schedule, { passive: true });
      window.addEventListener('resize', schedule, { passive: true });
      window.addEventListener('orientationchange', schedule, { passive: true });
      window.addEventListener('pageshow', schedule, { passive: true });
      document.addEventListener('visibilitychange', schedule, { passive: true });

      // Also re-fit after dynamic content render (cards built async)
      const list = document.getElementById('list');
      if (list){
        const mo = new MutationObserver(schedule);
        mo.observe(list, { childList: true, subtree: false });
      }
    })();

    // ë°ìŠ¤í¬í†±ìœ¼ë¡œ ìë™ ì „í™˜ (>=640px)
    (function responsiveRoute(){
      const DESKTOP_URL = './Project.html';
      const mq = window.matchMedia('(min-width: 640px)');
      function go(){ if (mq.matches) location.replace(DESKTOP_URL + location.search + location.hash); }
      go();
      if (mq.addEventListener) mq.addEventListener('change', e=>{ if (e.matches) go(); }, {passive:true});
      else if (mq.addListener) mq.addListener(e=>{ if (e.matches) go(); });
      window.addEventListener('orientationchange', go, {passive:true});
      window.addEventListener('resize', go, {passive:true});
    })();

    // í•œê¸€ ì´ˆì„± ìœ í‹¸
    const __CHO = ["ã„±","ã„²","ã„´","ã„·","ã„¸","ã„¹","ã…","ã…‚","ã…ƒ","ã……","ã…†","ã…‡","ã…ˆ","ã…‰","ã…Š","ã…‹","ã…Œ","ã…","ã…"];
    function toInitials(str){
      return (str||'').split('').map(ch => {
        const code = ch.charCodeAt(0) - 44032; // 0xAC00
        if (code >= 0 && code < 11172) return __CHO[Math.floor(code/588)];
        if (/^[ã„±-ã…]$/.test(ch)) return ch;
        if (/[A-Za-z0-9]/.test(ch)) return ch.toLowerCase();
        return ' ';
      }).join('');
    }

    // ë°ìŠ¤í¬í†± Project.htmlì—ì„œ ì¹´ë“œ ì •ë³´ë¥¼ ê°€ì ¸ì™€ ëª¨ë°”ì¼ ë¦¬ìŠ¤íŠ¸ êµ¬ì„±
    (function buildFromDesktop(){
      const list = document.getElementById('list');
      const cnt  = document.getElementById('cnt');
      const q    = document.getElementById('q');
      const filterNav = document.querySelector('.filter-scroll');
      const pills = document.querySelectorAll('.pill');
      let items = [];
      let currentFilter = 'all';

      // í˜„ì¬ í˜ì´ì§€(2025 ë””ë ‰í„°ë¦¬)ì˜ ì ˆëŒ€ ë””ë ‰í„°ë¦¬ ê²½ë¡œ (ëì— ìŠ¬ë˜ì‹œ í¬í•¨)
      const __BASE_DIR__ = location.pathname.replace(/[^/]*$/, '');
      // Helper: convert desktop personal-project href to mobile counterpart (generic mapping)
      function toMobileHref(href, fallbackName){
        try{
          // If there is no href, build from the fallbackName (Korean name on the card)
          if (!href) {
            if (fallbackName) {
              const baseDir = location.pathname.replace(/[^/]*$/, ''); // e.g., /2025/
              const encoded = encodeURIComponent(fallbackName);
              return `${baseDir}Project/${encoded}/Project-mobile_${encoded}.html`;
            }
            return '';
          }

          // Try to resolve into an absolute URL for robust parsing
          let abs;
          try { abs = new URL(href, location.href); }
          catch(_) {
            // If parsing fails, attempt a name-based fallback
            if (fallbackName) {
              const baseDir = location.pathname.replace(/[^/]*$/, '');
              const encoded = encodeURIComponent(fallbackName);
              return `${baseDir}Project/${encoded}/Project-mobile_${encoded}.html`;
            }
            return href;
          }

          // If filename matches Project_ì´ë¦„.html â†’ swap to Project-mobile_ì´ë¦„.html
          const base = abs.pathname.split('/').pop() || '';
          const m = base.match(/^Project_([^\/?#]+)\.html$/i);
          if (m) {
            const namePart = m[1];
            const pathMobile = abs.pathname.replace(/Project_([^\/?#]+)\.html$/i, 'Project-mobile_$1.html');
            return pathMobile + (abs.search || '') + (abs.hash || '');
          }

          // If already in a personal Project folder, just replace the filename
          if (/\/Project\/[^\/]+\/Project_[^\/]+\.html$/i.test(abs.pathname)) {
            return abs.pathname.replace(/Project_([^\/?#]+)\.html$/i, 'Project-mobile_$1.html') + (abs.search || '') + (abs.hash || '');
          }

          // Final fallback: build from the card's Korean name
          if (fallbackName) {
            const baseDir = location.pathname.replace(/[^/]*$/, '');
            const encoded = encodeURIComponent(fallbackName);
            return `${baseDir}Project/${encoded}/Project-mobile_${encoded}.html`;
          }

          return href;
        }catch(e){
          // On any unexpected error, fall back to the name-based rule if possible
          if (fallbackName) {
            const baseDir = location.pathname.replace(/[^/]*$/, '');
            const encoded = encodeURIComponent(fallbackName);
            return `${baseDir}Project/${encoded}/Project-mobile_${encoded}.html`;
          }
          return href;
        }
      }

      function render(){
        list.innerHTML = '';
        let visible = 0;
        const frag = document.createDocumentFragment();
        items.forEach(it => {
          const passFilter = (currentFilter === 'all' || it.category === currentFilter);
          const passSearch = !q.value || it.matches(q.value);
          if (passFilter && passSearch){
            visible++;
            const card = document.createElement('article');
            card.className = 'card';
            card.setAttribute('data-category', it.category);
            // Convert href to mobile target (generic mapping)
            let hrefMobile = toMobileHref(it.href, it.name);

            // Hard fallback: if the card title contains "ííŒ¨ìŠ¤", force-link to the exact mobile page
            // (covers cases where source markup uses an unexpected path or missing link)
            if ((it.title || '').replace(/\s/g,'').includes('ííŒ¨ìŠ¤')) {
              hrefMobile = '/2025/Project/ê¹€ì‚¬ìœ¨/Project-mobile_ê¹€ì‚¬ìœ¨.html';
            }
            card.innerHTML = `
              <a class="card-link" href="${hrefMobile}" aria-label="${it.title} ìƒì„¸ ë³´ê¸°" style="display:block; text-decoration:none; color:inherit;">
                <img src="${it.src}" alt="${it.title}" loading="lazy" decoding="async"/>
                <div class="cap">
                  <div class="t">${it.title}</div>
                  <div class="m">${it.name}${it.eng ? ` Â· <span>${it.eng}</span>`:''}</div>
                </div>
              </a>`;
            frag.appendChild(card);
          }
        });
        list.appendChild(frag);
        cnt.textContent = visible + ' Project';
      }

      function normalizeSrc(src){
        // ê·¸ëŒ€ë¡œ ì‚¬ìš© (ëª¨ë°”ì¼ê³¼ ë°ìŠ¤í¬í†±ì´ ê°™ì€ í´ë” êµ¬ì¡°)
        return src;
      }

      fetch('./Project.html', {cache:'no-store'})
        .then(r=>r.text())
        .then(html => {
          const doc = new DOMParser().parseFromString(html, 'text/html');
          const cards = doc.querySelectorAll('.project-gallery .project-gridcard');
          items = Array.from(cards).map(card => {
            const img = card.querySelector('img');
            const link = card.querySelector('a');
            const title = (card.querySelector('.title')?.textContent || card.getAttribute('data-title') || 'Project').trim();
            const name  = (card.querySelector('.text strong')?.textContent || card.getAttribute('data-name') || '').trim();
            const eng   = (card.querySelector('.text span')?.textContent || card.getAttribute('data-eng') || '').trim();
            const cat   = (card.getAttribute('data-category')||'all').trim();
            const src   = normalizeSrc(img ? (img.getAttribute('src')||'') : '');
            const href  = link ? (link.getAttribute('href') || '') : '';
            const hay   = (title + ' ' + name + ' ' + eng).toLowerCase();
            const init  = toInitials(hay).replace(/[^ã„±-ã…a-z0-9]/g, '');
            return {
              title, name, eng, category: cat, src, href,
              matches(q){
                q = (q||'').toLowerCase().trim();
                if (!q) return true;
                const hasCho  = /[\u3131-\u314e]/.test(q);
                const hasSyl  = /[\uac00-\ud7a3]/.test(q);
                if (hasCho){
                  const qi = toInitials(q).replace(/[^ã„±-ã…a-z0-9]/g, '');
                  return init.includes(qi);
                }
                if (hasSyl){
                  return hay.includes(q);
                }
                return hay.includes(q);
              }
            };
          });
          // === ì´ë¦„ìˆœ(í•œê¸€) ì •ë ¬: ë§í¬/í‘œì‹œ ëª¨ë‘ ì´ë¦„ ê¸°ì¤€ìœ¼ë¡œ ì˜¤ë¦„ì°¨ìˆœ ===
          (function sortByKoreanName(){
            try{
              const coll = new Intl.Collator('ko', { usage:'sort', sensitivity:'base', numeric:true });
              items.sort((a,b) => {
                const an = (a.name || '').trim();
                const bn = (b.name || '').trim();
                return coll.compare(an, bn);
              });
            }catch(_){}
          })();
          render();
        });

      // ê²€ìƒ‰
      q.addEventListener('input', () => render());

      // ê°€ë¡œ ìŠ¤í¬ë¡¤ ë„¤ë¹„ í•„í„° (ì´ë²¤íŠ¸ ìœ„ì„)
      if (filterNav){
        filterNav.addEventListener('click', (e)=>{
          const btn = e.target.closest('.pill');
          if (!btn) return;
          pills.forEach(b=> b.classList.remove('is-active'));
          btn.classList.add('is-active');
          currentFilter = btn.getAttribute('data-filter') || 'all';
          render();
        });
        // ì´ˆê¸° í™œì„±ê°’
        const active = document.querySelector('.pill.is-active');
        currentFilter = (active && active.getAttribute('data-filter')) || 'all';
      }
    })();
  </script>


</body>
</html>